#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <TM1637Display.h>
#include <EEPROM.h>

// ------------------ Konstanta dan Variabel ------------------

#define TM1637_CLK 4
#define TM1637_DIO 5
TM1637Display display(TM1637_CLK, TM1637_DIO);

// EEPROM addresses untuk menyimpan data permanen
#define EEPROM_MAGIC_ADDR 0        // Address untuk magic number (2 bytes)
#define EEPROM_DATA_START 2        // Address mulai data modeTimes (128 bytes = 32 modes x 4 bytes)
#define EEPROM_MAGIC_NUMBER 0x1234 // Magic number untuk validasi data

enum SystemMode
{
  MODE_IDLE,
  MODE_A1,
  MODE_A2,
  MODE_A3,
  MODE_A4,
  MODE_A5,
  MODE_A6,
  MODE_A7,
  MODE_A8,
  MODE_B1,
  MODE_B2,
  MODE_B3,
  MODE_B4,
  MODE_B5,
  MODE_B6,
  MODE_B7,
  MODE_B8,
  MODE_C1,
  MODE_C2,
  MODE_C3,
  MODE_C4,
  MODE_C5,
  MODE_C6,
  MODE_C7,
  MODE_C8,
  MODE_D1,
  MODE_D2,
  MODE_D3,
  MODE_D4,
  MODE_D5,
  MODE_D6,
  MODE_D7,
  MODE_D8
};

const int TOTAL_MODES = 32;
unsigned int modeTimes[TOTAL_MODES];

SystemMode currentMode = MODE_IDLE;
SystemMode nextMode = MODE_IDLE;
SystemMode selectedModeToSet = MODE_A1;

bool displayInitialized = false;
bool systemRunning = false;
bool inputMode = false;
bool waitingForTime = false;
bool modeJustFinished = false;
char currentGroup = ' ';

String inputValue = "";
unsigned int tempValue = 0;

unsigned long previousMillis = 0;
unsigned long interval = 0;

const int relayPin = 2;
const int switchPin = 53;

// Tambahkan variabel untuk filtering noise dan proteksi EMI
int switchState = HIGH;
int lastSwitchState = HIGH;
unsigned long lastDebounceTime = 0;
const unsigned long debounceDelay = 10; // Kurangi untuk responsivitas lebih baik
bool relayState = false;
unsigned long lastRelayChange = 0;

// Variabel untuk switch konstan tanpa jeda
bool switchPressed = false;
unsigned long switchPressTime = 0;
const unsigned long switchHoldDelay = 100; // Delay minimal antara aksi switch
bool constantSwitchMode = false;           // Mode switch konstan

// Variabel untuk proteksi system dari interferensi AC
bool systemStable = true;
unsigned long lastSystemCheck = 0;
int errorCount = 0;

int scrollOffset = 0; // 0 = Grup A–C, 1 = Grup D
int columnOffset = 0; // 0 = kolom 1–4, 1 = kolom 5–8

// ------------------ LCD & Keypad Setup ------------------

LiquidCrystal_I2C lcd(0x27, 20, 4); // LCD 20x4

const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}};

byte rowPins[ROWS] = {22, 24, 26, 28};
byte colPins[COLS] = {30, 32, 34, 36};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// ------------------ Fungsi Utilitas ------------------

// Fungsi untuk menyimpan data ke EEPROM
void saveToEEPROM()
{
  // Tulis magic number untuk validasi
  EEPROM.put(EEPROM_MAGIC_ADDR, EEPROM_MAGIC_NUMBER);

  // Simpan semua mode times
  for (int i = 0; i < TOTAL_MODES; i++)
  {
    int addr = EEPROM_DATA_START + (i * sizeof(unsigned int));
    EEPROM.put(addr, modeTimes[i]);
  }
}

// Fungsi untuk memuat data dari EEPROM
bool loadFromEEPROM()
{
  // Cek magic number untuk validasi data
  unsigned int magic;
  EEPROM.get(EEPROM_MAGIC_ADDR, magic);

  if (magic != EEPROM_MAGIC_NUMBER)
  {
    // Data tidak valid, inisialisasi dengan nilai default
    for (int i = 0; i < TOTAL_MODES; i++)
    {
      modeTimes[i] = 0;
    }
    return false;
  }

  // Load data yang tersimpan
  for (int i = 0; i < TOTAL_MODES; i++)
  {
    int addr = EEPROM_DATA_START + (i * sizeof(unsigned int));
    EEPROM.get(addr, modeTimes[i]);
  }
  return true;
}

// Fungsi untuk kontrol relay yang aman
void setRelay(bool state)
{
  // Cegah perubahan relay terlalu cepat (min 100ms interval untuk AC load)
  if (millis() - lastRelayChange < 100)
    return;

  if (relayState != state)
  {
    // Matikan interrupts sementara untuk mencegah interferensi
    noInterrupts();

    relayState = state;
    digitalWrite(relayPin, state ? LOW : HIGH); // LOW = ON, HIGH = OFF
    lastRelayChange = millis();

    // Nyalakan kembali interrupts
    interrupts();

    // HAPUS Serial.print untuk menghentikan RX berkedip
    // Serial komunikasi dapat menyebabkan interferensi dengan relay AC
  }
}

unsigned long safeMillisDiff(unsigned long now, unsigned long previous)
{
  return (now >= previous) ? (now - previous) : (4294967295UL - previous + now + 1);
}

int getModeIndex(SystemMode mode)
{
  return (int)mode - 1;
}

String getModeString(SystemMode mode)
{
  if (mode == MODE_IDLE)
    return "Idle";
  int index = getModeIndex(mode);
  char prefix = 'A' + (index / 8);
  int num = (index % 8) + 1;
  return String(prefix) + String(num);
}

void update7Segment(SystemMode mode)
{
  if (mode == MODE_IDLE)
  {
    display.clear();
    return;
  }
  int index = getModeIndex(mode);
  char prefix = 'A' + (index / 8);
  int num = (index % 8) + 1;

  uint8_t seg[4] = {0x00, 0x00, 0x00, 0x00};
  switch (prefix)
  {
  case 'A':
    seg[0] = 0x77;
    break;
  case 'B':
    seg[0] = 0x7C;
    break;
  case 'C':
    seg[0] = 0x39;
    break;
  case 'D':
    seg[0] = 0x5E;
    break;
  default:
    seg[0] = 0x00;
    break;
  }
  seg[1] = display.encodeDigit(num);
  display.setSegments(seg);
}

// Fungsi untuk update display 7-segment saat idle
void updateIdleDisplay()
{
  static unsigned long lastUpdate = 0;
  static bool showNextMode = false;

  // Jika mode baru saja selesai, langsung tampilkan mode selanjutnya
  if (modeJustFinished)
  {
    update7Segment(nextMode);
    return; // Keluar langsung, tidak perlu bergantian
  }

  // Update setiap 3 detik untuk bergantian menampilkan info (hanya saat idle normal)
  if (millis() - lastUpdate > 3000)
  {
    lastUpdate = millis();
    showNextMode = !showNextMode;

    if (showNextMode)
    {
      // Cari mode pertama yang memiliki waktu > 0 untuk ditampilkan
      SystemMode firstMode = MODE_IDLE;
      for (int i = 0; i < TOTAL_MODES; i++)
      {
        if (modeTimes[i] > 0)
        {
          firstMode = (SystemMode)(i + 1);
          break;
        }
      }

      if (firstMode != MODE_IDLE)
      {
        update7Segment(firstMode);
      }
      else
      {
        // Jika tidak ada mode yang diset, tampilkan "rdy" (ready)
        uint8_t seg[4] = {0x50, 0x5E, 0x6E, 0x00}; // r-d-y
        display.setSegments(seg);
      }
    }
    else
    {
      // Tampilkan "rdy" atau info lain saat bergantian
      uint8_t seg[4] = {0x50, 0x5E, 0x6E, 0x00}; // r-d-y
      display.setSegments(seg);
    }
  }
}

// ------------------ Setup & Loop ------------------

void setup()
{
  // NONAKTIFKAN Serial untuk mencegah interferensi dengan AC load
  // Serial.begin(9600); // COMMENT OUT untuk AC operation

  // Setup relay dengan proteksi ekstra untuk AC load
  pinMode(relayPin, OUTPUT);
  digitalWrite(relayPin, HIGH); // Pastikan relay OFF saat startup
  relayState = false;

  // Setup switch dengan pull-up internal dan filtering ekstra
  pinMode(switchPin, INPUT_PULLUP);

  // Delay stabilisasi lebih lama untuk AC load
  delay(200);

  // Setup LCD dengan error handling dan proteksi noise
  lcd.init();
  lcd.backlight();

  // Setup 7-segment display
  display.setBrightness(0x0f);
  display.clear();

  // Load data dari EEPROM
  bool dataLoaded = loadFromEEPROM();

  // Initialize dengan delay untuk stabilisasi
  showSplashScreen();

  // Tampilkan status data yang dimuat
  lcd.clear();
  lcd.setCursor(2, 1);
  if (dataLoaded)
  {
    lcd.print("Data Dimuat dari");
    lcd.setCursor(4, 2);
    lcd.print("EEPROM");
  }
  else
  {
    lcd.print("Data Kosong");
    lcd.setCursor(3, 2);
    lcd.print("Mulai Baru");
  }
  delay(1500);

  showMainScreen();

  // Initialize noise filter dan system protection
  lastRelayChange = millis();
  lastSystemCheck = millis();
  errorCount = 0;

  // Set tampilan awal 7-segment
  updateIdleDisplay();
}

void loop()
{
  static unsigned long lastKeypadTime = 0;
  static unsigned long lastWatchdog = 0;
  const unsigned long keypadInterval = 50;     // Kurangi interval untuk responsivitas
  const unsigned long watchdogInterval = 2000; // 2 detik untuk AC load

  // System stability check untuk AC load protection
  if (millis() - lastSystemCheck >= 5000) // Cek setiap 5 detik
  {
    lastSystemCheck = millis();

    // Reset error count jika sistem stabil
    if (systemStable)
    {
      errorCount = 0;
    }

    // Jika terlalu banyak error, restart display
    if (errorCount > 3)
    {
      lcd.init();
      lcd.backlight();
      showMainScreen();
      errorCount = 0;
    }
  }

  // Watchdog untuk deteksi sistem hang dengan proteksi AC
  if (millis() - lastWatchdog >= watchdogInterval)
  {
    lastWatchdog = millis();

    // Cek apakah LCD masih responsif
    static int watchdogCounter = 0;
    watchdogCounter++;

    // Reset jika sistem tidak responsif > 30 detik
    if (watchdogCounter > 30 && !systemRunning)
    {
      watchdogCounter = 0;
      // Soft reset display
      lcd.init();
      lcd.backlight();
      showMainScreen();
    }
  }

  if (millis() - lastKeypadTime >= keypadInterval)
  {
    lastKeypadTime = millis();
    char key = keypad.getKey();
    if (key)
      handleKeypadInput(key);
  }

  // Baca switch setiap loop untuk responsivitas maksimal
  readSwitch();

  if (systemRunning && interval > 0)
    runSystem();
  else
  {
    // Update 7-segment display saat sistem idle
    updateIdleDisplay();
  }
}

// ------------------ Fungsi Tampilan ------------------

void showSplashScreen()
{
  lcd.clear();
  lcd.setCursor(5, 0);
  lcd.print("Timer Multi");
  lcd.setCursor(5, 1);
  lcd.print("CONTROLLER");
  lcd.setCursor(2, 3);
  lcd.print("Versi : 32 mode");
  delay(2000);
  lcd.clear();
  lcd.setCursor(3, 0);
  lcd.print("Build BY AGUS F");
  lcd.setCursor(3, 2);
  lcd.print("07 Agustus 2025");
  lcd.setCursor(0, 3);
  lcd.print("//github.com/sembre/");
  delay(3000);
}

void showMainScreen()
{
  lcd.clear();
  if (systemRunning)
  {
    updateRunningDisplay();
  }
  else
  {
    showAllModeTimes();
    setRelay(false); // Gunakan fungsi setRelay yang aman
    // JANGAN clear display - biarkan menampilkan mode terakhir atau status
    updateIdleDisplay();
  }
}

void showAllModeTimes()
{
  lcd.clear();

  lcd.setCursor(0, 0);
  lcd.print("    ");
  for (int j = 0; j < 4; j++)
  {
    lcd.print(columnOffset * 4 + j + 1);
    lcd.print("   ");
  }

  // Tampilkan indikator mode switch di pojok kanan atas
  lcd.setCursor(19, 0);
  if (constantSwitchMode)
  {
    lcd.print("K"); // K = Konstan
  }
  else
  {
    lcd.print("N"); // N = Normal
  }

  for (int i = 0; i < 3; i++)
  {
    int groupIndex = scrollOffset * 3 + i;
    if (groupIndex >= 4)
      break;

    lcd.setCursor(0, i + 1);
    char label = 'A' + groupIndex;
    lcd.print(label);
    lcd.print(":");

    for (int j = 0; j < 4; j++)
    {
      int col = columnOffset * 4 + j;
      int index = groupIndex * 8 + col;
      float detik = modeTimes[index] / 1000.0;

      lcd.print(" ");
      if (detik < 10)
        lcd.print("");
      lcd.print(detik, 1);
    }
  }
}

void updateRunningDisplay()
{
  // Baris 0: hanya sekali ditulis saat awal mode
  static bool initialized = false;
  if (!displayInitialized)
  {
    lcd.setCursor(0, 0);
    lcd.print("Menjalankan ");
    lcd.print(getModeString(currentMode));
    lcd.print(" ");
    lcd.print(modeTimes[getModeIndex(currentMode)] / 1000.0, 1);
    lcd.print("s");

    lcd.setCursor(0, 2);
    lcd.print("Selanjutnya ");
    lcd.print(getModeString(nextMode));
    lcd.print(" ");
    lcd.print(modeTimes[getModeIndex(nextMode)] / 1000.0, 1);
    lcd.print("s");

    update7Segment(currentMode);
    displayInitialized = true;
  }

  // Baris 1: progress bar diperbarui setiap saat
  lcd.setCursor(0, 1);
  int barLength = 20;
  unsigned long elapsed = safeMillisDiff(millis(), previousMillis);
  int filledBlocks = (interval > 0) ? map(elapsed, 0, interval, 0, barLength) : 0;
  if (filledBlocks > barLength)
    filledBlocks = barLength;

  for (int i = 0; i < barLength; i++)
  {
    lcd.print(i < filledBlocks ? "\xFF" : " ");
  }
}

void showModeComplete()
{
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(getModeString(currentMode));
  lcd.print(" Selesai (");
  lcd.print(modeTimes[getModeIndex(currentMode)] / 1000.0, 1);
  lcd.print("s)");

  lcd.setCursor(0, 2);
  lcd.print("Selanjutnya ");
  lcd.print(getModeString(nextMode));
  lcd.print(": ");
  lcd.print(modeTimes[getModeIndex(nextMode)] / 1000.0, 1);
  lcd.print("");

  update7Segment(nextMode);
}

// ------------------ Mode ------------------

void determineNextMode()
{
  int index = getModeIndex(currentMode);
  for (int i = 1; i <= TOTAL_MODES; i++)
  {
    int nextIndex = (index + i) % TOTAL_MODES;
    if (modeTimes[nextIndex] > 0)
    {
      nextMode = (SystemMode)(nextIndex + 1);
      return;
    }
  }
  nextMode = currentMode;
}

void startMode(SystemMode mode)
{
  currentMode = mode;
  systemRunning = true;
  determineNextMode();
  int index = getModeIndex(mode);
  interval = (index >= 0 && index < TOTAL_MODES) ? modeTimes[index] : 0;
  if (interval > 0)
  {
    setRelay(true); // Gunakan fungsi setRelay yang aman
    previousMillis = millis();
    displayInitialized = false;
    updateRunningDisplay();
  }
  else
  {
    systemRunning = false;
  }
}

void runSystem()
{
  unsigned long currentMillis = millis();
  if (safeMillisDiff(currentMillis, previousMillis) >= interval)
  {
    setRelay(false); // Gunakan fungsi setRelay yang aman
    systemRunning = false;
    modeJustFinished = true;
    showModeComplete();
    // Tampilkan mode berikutnya di 7-segment
    update7Segment(nextMode);
  }
  else
  {
    updateRunningDisplay(); // Update tampilan setiap loop
  }
}

void readSwitch()
{
  // Baca switch langsung tanpa interrupt blocking untuk responsivitas maksimal
  int reading = digitalRead(switchPin);

  // Mode switch konstan - langsung eksekusi tanpa debounce
  if (constantSwitchMode)
  {
    if (reading == LOW && !switchPressed)
    {
      switchPressed = true;
      switchPressTime = millis();

      // Eksekusi aksi switch langsung
      if (!systemRunning && currentMode == MODE_IDLE && systemStable)
      {
        for (int i = 0; i < TOTAL_MODES; i++)
        {
          if (modeTimes[i] > 0)
          {
            startMode((SystemMode)(i + 1));
            break;
          }
        }
      }
      else if (!systemRunning && modeJustFinished && systemStable)
      {
        startMode(nextMode);
        modeJustFinished = false;
      }
    }
    else if (reading == HIGH)
    {
      switchPressed = false;
    }
    return; // Skip debounce logic untuk mode konstan
  }

  // Mode normal dengan debounce
  if (reading != lastSwitchState)
  {
    lastDebounceTime = millis();
  }

  // Gunakan debounce yang lebih pendek untuk responsivitas
  if (safeMillisDiff(millis(), lastDebounceTime) > debounceDelay)
  {
    if (reading != switchState)
    {
      switchState = reading;

      // Jika switch ditekan (LOW)
      if (switchState == LOW)
      {
        // Cek apakah sudah cukup waktu sejak aksi terakhir
        if (!switchPressed || safeMillisDiff(millis(), switchPressTime) > switchHoldDelay)
        {
          switchPressed = true;
          switchPressTime = millis();

          // Eksekusi aksi switch
          if (!systemRunning && currentMode == MODE_IDLE && systemStable)
          {
            // Mulai dari mode pertama yang ada waktu
            for (int i = 0; i < TOTAL_MODES; i++)
            {
              if (modeTimes[i] > 0)
              {
                startMode((SystemMode)(i + 1));
                break;
              }
            }
          }
          else if (!systemRunning && modeJustFinished && systemStable)
          {
            // Lanjut ke mode berikutnya
            startMode(nextMode);
            modeJustFinished = false;
          }
        }
      }
      else
      {
        // Switch dilepas (HIGH)
        switchPressed = false;
      }
    }
  }

  lastSwitchState = reading;
}

// ------------------ Input Keypad ------------------

void handleKeypadInput(char key)
{
  // Emergency stop dengan double asterisk untuk AC load
  static unsigned long lastAsterisk = 0;
  if (key == '*')
  {
    if (millis() - lastAsterisk < 1000)
    { // Double * dalam 1 detik
      emergencyStop();
      return;
    }
    lastAsterisk = millis();
  }

  if (key == '*' && !inputMode)
  {
    resetAll();
  }
  else if (key == 'D' && !inputMode)
  {
    scrollOffset = (scrollOffset + 1) % 2;
    showAllModeTimes();
  }
  else if (key == 'C' && !inputMode)
  {
    columnOffset = (columnOffset + 1) % 2;
    showAllModeTimes();
  }
  else if (key == 'B' && !inputMode)
  {
    // Toggle mode switch konstan
    constantSwitchMode = !constantSwitchMode;
    lcd.clear();
    lcd.setCursor(2, 1);
    lcd.print("Mode Switch:");
    lcd.setCursor(3, 2);
    if (constantSwitchMode)
    {
      lcd.print("KONSTAN ON");
    }
    else
    {
      lcd.print("NORMAL ON");
    }
    delay(1500);
    showAllModeTimes();
  }
  else if (key == '#' && !inputMode)
  {
    inputMode = true;
    inputValue = "";
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("  Pilih Mode A1-D8");
    lcd.setCursor(0, 2);
    lcd.print("Pencet A,B,C atau D");
    lcd.setCursor(0, 3);
    lcd.print("lalu tekan 1-8");
  }
  else if (inputMode && !waitingForTime && key >= 'A' && key <= 'D')
  {
    currentGroup = key;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Grup: ");
    lcd.print(currentGroup);
    lcd.setCursor(0, 1);
    lcd.print("Kemudian Tekan ");
    lcd.setCursor(0, 2);
    lcd.print(" 1,2,3,4,5,6,7,8");
  }
  else if (inputMode && !waitingForTime && key >= '1' && key <= '8')
  {
    int group = currentGroup - 'A';
    int number = key - '1';
    selectedModeToSet = (SystemMode)(group * 8 + number + 1);
    waitingForTime = true;
    inputValue = "";
    tempValue = 0;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Input Set ");
    lcd.print(getModeString(selectedModeToSet));
    lcd.setCursor(0, 1);
    lcd.print("Input dalam ms      Kemudian Tekan #");
  }
  else if (waitingForTime && isdigit(key))
  {
    inputValue += key;
    if (inputValue.length() > 5)
      inputValue = inputValue.substring(0, 5);
    tempValue = inputValue.toInt();
    lcd.setCursor(0, 2);
    lcd.print(inputValue);
    lcd.print(" ms  (");
    lcd.print(tempValue / 1000.0, 1);
    lcd.print("s)");
  }
  else if (waitingForTime && key == '#')
  {
    saveInput();
  }
}

void saveInput()
{
  if (selectedModeToSet >= MODE_A1 && selectedModeToSet <= MODE_D8)
  {
    modeTimes[getModeIndex(selectedModeToSet)] = tempValue;

    // Simpan ke EEPROM agar tidak hilang saat dimatikan
    saveToEEPROM();

    inputMode = false;
    waitingForTime = false;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(getModeString(selectedModeToSet));
    lcd.print(" = ");
    lcd.print(tempValue);
    lcd.print("ms  (");
    lcd.print(tempValue / 1000.0, 1);
    lcd.print("s)");
    lcd.setCursor(0, 2);
    lcd.print(" Tersimpan Permanen");
    delay(2000);
    showAllModeTimes();
  }
  else
  {
    // Jika tidak memilih mode valid
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("  Gagal Disimpan!");
    lcd.setCursor(0, 2);
    lcd.print("Silakan Ulangi lagi");
    delay(2000);

    // Kembali ke tampilan input mode
    inputMode = true;
    waitingForTime = false;
    inputValue = "";
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("  Pilih Mode A1-D8");
    lcd.setCursor(0, 2);
    lcd.print("Pencet A,B,C atau D");
    lcd.setCursor(0, 3);
    lcd.print("lalu tekan 1-8");
  }
}

// Fungsi untuk recovery dari interferensi AC
void emergencyStop()
{
  noInterrupts();
  setRelay(false);
  systemRunning = false;
  modeJustFinished = false;
  systemStable = false;
  errorCount++;
  interrupts();

  lcd.clear();
  lcd.setCursor(2, 1);
  lcd.print("EMERGENCY STOP");
  lcd.setCursor(3, 2);
  lcd.print("AC Interference");
  delay(2000);

  // Reset system state
  systemStable = true;
  showMainScreen();
}

void resetAll()
{
  // Reset data dalam RAM
  for (int i = 0; i < TOTAL_MODES; i++)
    modeTimes[i] = 0;

  // Hapus juga data di EEPROM untuk reset permanen
  saveToEEPROM();

  inputMode = false;
  waitingForTime = false;
  currentMode = MODE_IDLE;
  systemRunning = false;
  modeJustFinished = false;
  setRelay(false); // Gunakan fungsi setRelay yang aman
  lcd.clear();
  lcd.setCursor(2, 1);
  lcd.print("Reset Permanen");
  lcd.setCursor(1, 2);
  lcd.print("Data EEPROM Dihapus");

  // Tampilkan "rdy" di 7-segment setelah reset
  uint8_t seg[4] = {0x50, 0x5E, 0x6E, 0x00}; // r-d-y
  display.setSegments(seg);

  delay(2000);
  showMainScreen();
}
